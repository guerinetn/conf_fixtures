= Fixtures et si on allait au-delà des données
:icons: font
:revealjs_theme: simple
:revealjs_slideNumber: true
:revealjs_history: true
:revealjs_pdfseparatefragments: false
:source-highlighter: highlight.js
:revealjs_width: 1280
:customcss: css/custom.css
:toc:

[NOTE.speaker]
====
Bonjour merci aux organisateurs de me permettre de participer au sud ouest Days.

Aujourd'hui, je vais vous parler de fixtures mais pas que, et si on allait au-delà des données ?

====

== Quand vous arrivez sur un projet...

[NOTE.speaker]
====
Je ne sais pas pour vous, mais en général, pour moi, quand je commence à travailler sur un projet existant.

Cela commence par cela.
====

[.columns]
[%notitle]  
=== L'installation ...

[.column]
--
image::images/intro/readme.png[readme,100px]
--
[.column]
--
image::images/intro/git.png[git,100px]
--

[.column]
--
image::images/intro/npm.png[npm,100px]
--

[.column]
--
image::images/intro/logo-composer-transparent.png[composer,100px]
--

[.column]
--
image::images/intro/docker-compose.png[docker,100px]
--

[.column]
--
image::images/intro/doctrine-logo.svg[doctrine,100px]
--

[NOTE.speaker]
====
* Je lis le readme, oui oui, c'est intéressant à lire, bon ok pas tout, mais au moins les étapes d'installation.
* Je récupère les sources,
* J'installe les dépendances,
* Je lance les containers ou configure nos briques techniques.
* J'initialise le schéma de base de données et je lance mes migrations
* Et je suis prêt à travailler, enfin presque.

====

[.columns]
=== Et les données ?

[.column]
--
[step=1]
image::images/intro/task.png[task,300px]
--

[.column]
--
[step=2]
image::images/intro/old_hdd.png[task,300px]
--

[.column]
--
[step=4]
image::images/intro/404.png[404,600px]
--

[.column]
--
[step=3]
image::images/intro/dump_prod.png[dump,300px]
--

[NOTE.speaker]
====

* Finalement, c'est "intéressant" de lire tout le readme, il y a la procédure d'initialisation des données en 300 étapes (ou presque).
* Ou alors, on a un dump de la base de données de production (anonymisé bien sûr)

Dans mon cas, il n'y avait pas de procédure d'anonymisation ni procédure capilotractée pour l'initialisation des données.

Du coup et comme je n'avais pas envie de tout faire à la main, j'ai commencé à essayer de trouver une solution.
Apparemment, tout le monde me dit qu'il faut mettre en place des fixtures.

La suite de cette conférence est un retour d'expérience sur la mise en place de fixtures au sein de mon projet.
====

[.columns]
== Qui suis-je ?

[.column]
--
image::images/avatar.png[nico,80%]
--

[.column.has-text-left]
--
**Nicolas**

Développeur PHP, Symfony

TechLead PHP, Architecte
--

[.column]
--
image::images/gop-mini.png[gop,80px,float="left"]
onepoint BDX
--

== Contexte

[NOTE.speaker]
====
Le projet sur lequel nous travaillons est une application web composée de 3 briques.
Un backend PHP, un front en angular et une brique d'authentification avec KeyCloak.

Cette application gère des demandes d'agrément.
Une demande a un cycle de vie complexe, nous avons besoin de mettre en place des jeux de données pour chaque état.

Présenter le workflow MAR et présenter notre workflow

Demande => ajout de fichier => deposer la demande => donner son avis par périmètre => finaliser agrément

Une demande comprend
* l'identité de notre demandeur,
* des informations sur ses qualifications.
* des informations sur sa société.
* plusieurs fichiers relatifs à sa demande
* un périmètre d'intervention sur lequel son agrément va être valide.

Une fois un dossier constitué un demandeur va déposer son dossier.
Ces demandes sont instruites par des instructeurs et des superviseurs.
Une demande déposée va être ensuite affectée à un instructeur par un superviseur.
L'instructeur instruit le dossier et donne son avis passant ensuite la main à un superviseur.
Le superviseur va confirmer ou non l'avis de l'instructeur et valider ou refuser la démande d'agrément.

Chaque étape doit être historisée afin de permettre un audit de ce process étape par étape et tracer qui à fait quelle action.

J'ai donc besoin de créer des données pour chacune de ces opérations.

Comme précisé précédemment, on m'a conseillé de mettre en place des fixtures.
Le projet étant en symfony, je me suis ainsi tourné vers le DoctrineFixtureBundle de Symfony.
====

=== FixtureBundle

 Permet l'ordonnancement de la création de données
 Fournit un registre de données
 Permet la gestion de l'écrasement des données

[NOTE.speaker]
====

* Jouer différents jeux de données
* Permettre de stocker certaines références pour les réutiliser (un utilisateur spécial, un produit)
* BDD
** Ajout seul
** Purge avec suppression partielle
====

=== Première étape

[source, php,%linenums,highlight="1..4|5..8|10..12|13"]
----
class AppFixturesBasis extends Fixture
{
    public function load(ObjectManager $manager): void
    {
        $demandeur = new Demandeur();
        $demandeur->setEmail('test@test.test');
        $demandeur->setFirstname('John');
        $demandeur->setLastname('Doe');

        $manager->persist($demandeur);
        $manager->flush();

        $this->addReference('DEMANDEUR', $demandeur);
    }
}
----

[NOTE.speaker]
====

Ok on a un objet Demandeur mais un demandeur c'est beaucoup de données.
Et un utilisateur doit se connecter à Keycloak.
Il faut donc créer une fonction permettant de créer un utilisateur dans Keycloak.
N'a-t-on pas un service qui permet de créer un utilisateur dans l'application ?
====

=== Créons donc un Candidat.

[source, php,%linenums,highlight="3..10|11"]
----
public function load(ObjectManager $manager): void
{
    $candidate = new Candidate();

    $candidate->setFirstName("John");
        ->setLastName("Doe")
        ->setEmail("john.doe@test.test")
        ->setSiren("123456789")
        ->setName("Société")
        ->setPassword("motDePasse");
    $this->candidateService->create($candidate);
    $candidate->getUser()->setRoles([Role::ROLE_DEMANDEUR->name]);
}
----

[NOTE.speaker]
====
Maintenant, on a un candidat, mais surtout un candidat avec lequel on pourra se connecter dans l'application.
====

=== Passons donc aux demandes

[source, php,%linenums,highlight="7..28|30"]
----
$candidate = $this->creeDemandeur("John", "Doe", "john.doe@test", "123456789", "Société", "motDePasse");
$candidate->getUser()->setRoles([Role::ROLE_DEMANDEUR->name]);
$commune = $this->communeRepository->findOneBy(['nom' => 'Bordeaux']);

$param = [
    'demandeur' => [
        'tel' => '+33600000000',
        'company' => [
            'email' => 'company@boite.mail',
            'tel' => '+33600000000',
            'formeJuridique' => 'autres',
            'creationDate' => '2024-01-01',
        ],
    ],
    'adresse' => [
        'adresse1' => 'numéro, nom de la voie',
        'adresse2' => 'complément adresse',
        'codePostal' => $commune->getCodePostaux()[0],
        'codeDepartement' => $commune->getDepartement()->getCode(),
        'ville' => $commune->getNom(),
    ],
];

return $this->demandeService->creeDemande($demandeur, $param);
----

[NOTE.speaker]
====
Une demande, c'est beaucoup d'informations, mais dans notre cas ce qui nous intéresse c'est le périmètre de la demande.
On peut également factoriser notre code pour le demandeur.
Là encore, on pourrait créer tous les objets, mais on a un service qui nous permet cela.
Encore une fois, on va utiliser le service pour créer notre demande.
====

=== Les fichiers

image::images/fichier_test.png[fichier,300px]


[NOTE.speaker]
====
La complexité est qu'une demande est composée de plusieurs fichiers.
Et qu'il faut les télécharger sur l'application.
Le contenu du fichier, on s'en moque un peu, mais il faut qu'il y en ait un pour que par la suite on puisse les manipuler dans l'application.
====

=== Les fichiers

[source,php,%linenums,highlight="1..9|11..19"]
----
public function createUploadedFile(string $nom): UploadedFile
{
    $this->filesystem->copy(
        originFile:'/var/www/html/src/DataFixtures/test_files/test.pdf',
        targetFile: "/tmp/$nom",
        overwriteNewerFiles: true);

    return new UploadedFile("/tmp/$nom", $nom, 'application/pdf', test: true);
}

$this->pieceJointeService->createPieceJointe(
    new PieceJointeModel(
        $nom,
        $this->fixtHelpers->createUploadedFile($nom),
        $demande,
        $demande->getDemandeur(),
        $codeTypePj
    )
);

=== Récapitulons



----

[NOTE.speaker]
====
On a donc une fonction qui permet de créer un fichier qui pourra être manipulé par notre application
====


=== SymfonyClock

[%step]
* Remplacement de la fonction now()
* Possibilité de remplacer l'horloge :
** `NativeClock` : date système standard
** `MockClock` : fixe l'heure
** `MonotonicClock` : horloge monotone

[NOTE.speaker]
====
NativeClock pour la prod
MockClock pour les tests
MonotonicClock pour les tests de performances ou le monitoring
====

== En résumé

image::images/process.svg[process,75%]

=== Nous avons besoin de quoi

[%step]
* Raconter une histoire (YAML)
* Des objets immuables (YAML)
* De parcourir des fichiers (PHP)
* De vérifier un peu (PHP)
* D'orchestrer tout ça (PHP)

=== Pourquoi faire des fixtures

[%step]
* Gagner du temps
* Avoir des données cohérentes
* Donner du contexte à des tests
* Vérifier nos services
* Avoir des données fiables
* Moins coder.

== Merci
